In this discussion (https://groups.google.com/g/adda-discuss/c/BXBZMMnDwuM), it was suggested that a code able to differentiate between forward and backward efficiencies (defined with respect to the impinging light direction) would be useful to the ADDA community. Therefore, I am sharing a python code that I’m using to simulate the amount of light transmitted and reflected by spheres, as well as custom shapes, lying on a substrate for a spectrum of wavelengths.
It is a sort of stand-alone compiler to be put in the ADDA directory, as it both launches the simulations and then reads the outputs. The main advantages are:

•	Separation of the scattering cross section into the forward and backward component, also in surface mode (eq. 66 of the manual);
•	user-dependent theta and phi angle grid;
•	Built-in parallel simulations of wavelength spectra and custom shapes, with clear folder and output files names, and of Mie efficiencies for comparison.
•	Guide available.

The python script and guide may be found at https://drive.google.com/drive/folders/1NCNRca60HqnRZOXDdlva6jbG9POnmfpJ?usp=sharing

All interested users are advised to read carefully the guide and to double-check the results. Any inquiries, suggestion and bug report will be very appreciated. You can also reach me at mattia.andrini@unicatt.it.
Hope this helps someone!
"""
V1.0

@author: mattia.andrini@unicatt.it

You can write me for anything regarding the code. Suggestions are welcome.

I do not claim myself to be a good programmer. Please be kind :D

"""
import matplotlib.pyplot as plt
import time
import miepython
import numpy as np
import pylab
import subprocess
global input_filename
from concurrent.futures import ThreadPoolExecutor, as_completed
import os

'this code allows to run controlled simualtion with the software ADDA given a wavelength spectrum input.'
'To modify the ADDA simulation, refer to "generate_bat_file" function and to the guide'

Mainfolder="C:\\your path to\\adda-1.4.0\\win64\\" #set name of the working folder
SimResfolder = r"C:\\your path to\SimulationResults" #specify the full path where you want to save the scattering results

particle_shape = "sphere_test"        #select particle shape. feature not fully implemented: used only as a label to differentiate between folders. To change particle shape, you need to change the commands in function "generate_bat_files"
input_filename="lambda_nk_test.txt"   #input file as lambda - n - k of the particles and n of the substrate. n of the substrate can be avoided if you are not putting in the simulation

substrate_presence="no"                         #select if you need to consider the substrate or not

theta_grid=np.arange(start=0,stop=180.1,step=0.5)  #Update the grid values from the step you have chosen in scat_params.dat. 
phi_grid=np.arange(start=0,stop=360.5,step=2)       #Defaults are theta from 0 to 180° with 2° steps, phi from 0° to 360° with 6° steps.

data = np.loadtxt(input_filename)                   #Load the data from the file
data = np.atleast_2d(data)                          # Make sure it's at least 2D so slicing works even for a single row

wavelength = data[:, 0]   # wavelength values
PS_n       = data[:, 1]   # real part of RI
PS_k       = data[:, 2]   # imaginary part of RI
sub_n      = data[:, 3]   # substrate RI

grid_value=32             #fix grid of the dipoles as number of dipoles along the x axis, thus the size of the matrix to be computed. Calculation time scales as cube of number of dipoles.
                          #While working with custom shapes this value is not considered but is taken directly from the .geom file. It si still used to flag the file name.                         

number_of_dipoles_in_a_row=str(grid_value)      #convert grid size to integer in order to correctly upload the folder

radius=np.array([81,82,83,84,85]) #Function go_mult_radius() performs simulations for each value of this array in sequence.

parallel_processes=4        #set number of processes (every process is a different simulation in wavelength) to be run in parallel.
                            #should not be more than the number of threads of the pc.                  

def go(a):                  #main function to perform a simulation for a given size "a" (radius if spheres, otherwise check the actual dimension) for a full spectrum specified in the .txt file "input_filename"
    start_time=time.time()                  #needed to print the time needed for the simulation
    bat_files = []
    for k in range(wavelength.shape[0]):    #for each wavelength in the input_file, it creates a batch file with the lambda and refractive index of the k-row corresponding to that lambda.
        bat_file=generate_bat_file(wavelength[k],PS_n[k],PS_k[k],sub_n[k],k,a)
        bat_files.append((bat_file, k))
                           #batch files are run one each time, for each wavelength.
     # 2. Run batch files in parallel
    print("Starting parallel simulations...") #used to perform simulations in parallel, time used for each wavelength is printed in the console.
    with ThreadPoolExecutor(max_workers=parallel_processes) as executor:
        futures = [executor.submit(run_batch_file, bat_file, k) for bat_file, k in bat_files]
        for future in as_completed(futures):
            future.result()
    
    for bat_file, _ in bat_files:  #removes bat files at the end of the simulation. comment this "for" if you have troubles to keep the .bat files for debugging. add "pause" at the end of the .bat file to read the .cmd comments and see what's wrong.
        try:
            os.remove(bat_file)
        except Exception as e:  
            print(f"Could not delete {bat_file}: {e}")

    print(f"R={a}nm simulation took: {time.time() - start_time:.2f} seconds")
    print('Simulation performed!')
    return
    
def generate_bat_file(wavelength,PS_n,PS_k,sub_n,k,a):            #first variable is the wavelength, it writes in the batch the values in micrometer (ADDA takes micron). The output folder will display wavelenth, particle shape, substrate presence, grid, particle n and dimension to assure unicity.
    bat_filename = f"run_{k}.bat"

    if substrate_presence=="yes":                        #while working in surface mode, reference system must be adapdted. see guide
        with open(bat_filename, 'w') as f:               #writes instruction for ADDA
            f.write('echo off\n')                           #makes prompt to shut up and avoid chaos
            f.write('cd win64\n')                           #set folder
            wavelength_micro = float(wavelength)/1000       #ADDA uses micrometer units for wavelength and radius, while I use nanometers
            lambda_value=int(wavelength)
            eq_rad_value=float(a)/1000
            command = (                                     #set of commands, refer to ADDA guide.
                    f"adda -Csca -scat_matr muel " #with -store_scat_grid option, change angle spacing in scat_param.dat
                    f"-lambda {wavelength_micro} "
                    f"-shape sphere -grid {grid_value} "   #if you use standard shapes from ADDA, use this command. 
                    #f"-shape read yourshape.geom "       #if you work with custom shape, use this command and put the .geom file in the win64 directory.
                    f"-ntheta 360 "                         #use to change theta step if -store_scat_grid option is disabled.
                    f"-m {PS_n} {PS_k} "
                    f"-eq_rad {eq_rad_value} "     #default, I use equivalent radius definition for defining sizes. refer to the guide for details.
                    f"-surf {eq_rad_value} {sub_n} 0 -prop 0 0 -1 " #surface mode.       
                    f"-dir run{lambda_value}_{particle_shape}_sub{substrate_presence}_g{grid_value}_m{PS_n}_R{int(a)} \n ") #set the name of the folder. if you change this, you will need to update the folder name in upload function.                    
            f.write(command)
        return bat_filename    
            
    if substrate_presence=="no":  
        with open(bat_filename, 'w') as f:               #writes instruction for ADDA
            f.write('echo off\n')                           #makes prompt to shut up and avoid chaos
            f.write('cd win64\n')                           #set folder (?)
            wavelength_micro = float(wavelength)/1000       #ADDA need micrometer as input for wavelength and radius
            lambda_value=int(wavelength)
            eq_rad_value=float(a)/1000
            command = (                                     #set of commands, refer to ADDA guide for understand the meaning.
                        f"adda -Csca -scat_matr muel -store_scat_grid "
                        f"-lambda {wavelength_micro} "
                        f"-shape sphere -grid {grid_value} "
                        #f"-shape read yourshape.geom "
                        f"-ntheta 360 "  #use to change theta step if -store_scat_grid option is disabled
                        f"-m {PS_n} {PS_k} "
                        f"-eq_rad {eq_rad_value} "
                        f"-dir run{lambda_value}_{particle_shape}_sub{substrate_presence}_g{grid_value}_m{PS_n}_R{int(a)} \n ") #-dir <dirname> f"-surf {eq_rad_value} {sub_n} 0 -prop 0 0 -1 "                        
            f.write(command)       
        return bat_filename

def run_batch_file(bat_file, k):      #just runs the .bat file and prints the simulation time for each wavelength. not intended to be used alone. 
    start_time = time.time()
    try:            #to print time needed to simulate each batch file. redundant?
        result = subprocess.run(bat_file, shell=True, check=True)
        end_time = time.time()
        elapsed = end_time - start_time
        #print(f"Batch file completed with return code: {result.returncode}")
        print(f"{wavelength[k]} simulation took: {elapsed:.2f} seconds")
    except subprocess.CalledProcessError as e:
        print(f"Error running batch file: {e}")


def upload(a):      #upload values from a simulation, calculates scattering quantities and saves them in a .txt file. USE WITHOUT -store_scat_grid 
    
# Handle the run parameters
    if wavelength.shape[0] > 1:
        initial_run = int(wavelength[0])
        step_lambda = int(wavelength[1] - wavelength[0])
        final_run = initial_run + step_lambda * wavelength.shape[0]
    else:
        initial_run = int(wavelength[0])
        step_lambda = 1   # no step if only one point
        final_run = initial_run+step_lambda     #function discontinued
    
    S11_muel = np.zeros((len(theta_grid), wavelength.shape[0]))   #just inizialize the arrays
    Pol_Y = np.zeros((6, wavelength.shape[0]))
    Pol_X = np.zeros((6, wavelength.shape[0]))
    Q_ext_ADDA_autoY = np.zeros(wavelength.shape[0])
    Q_abs_ADDA_autoY = np.zeros(wavelength.shape[0])
    Q_ext_ADDA_autoX = np.zeros(wavelength.shape[0])
    Q_abs_ADDA_autoX = np.zeros(wavelength.shape[0])
    Q_sca_ADDA_intY = np.zeros(wavelength.shape[0])
    Q_sca_ADDA_intX = np.zeros(wavelength.shape[0])  
    C_ext_ADDA_autoY = np.zeros(wavelength.shape[0])
    C_abs_ADDA_autoY = np.zeros(wavelength.shape[0])
    C_ext_ADDA_autoX = np.zeros(wavelength.shape[0])
    C_abs_ADDA_autoX = np.zeros(wavelength.shape[0])
    C_sca_ADDA_intY = np.zeros(wavelength.shape[0])
    C_sca_ADDA_intX = np.zeros(wavelength.shape[0])
    

    for j, wl in enumerate(wavelength):
        i = int(wl)  # wavelength value, used for folder naming
        
        if i<10:
            run = "00" + str(i)
        if i>=10 and i<100:
            run = "0" + str(i)
        else:
            run = str(i)       
        
        MuelMatrx = Mainfolder + "run" + run + "_" + \
        particle_shape + "_sub"+ substrate_presence+ "_g" + number_of_dipoles_in_a_row + \
        "_m" + str(PS_n[j]) + "_R" + str(a) +"\\mueller"   #location of mueller matrix
        
        
        #j = int((i - initial_run)/step_lambda)
        
        
        if wavelength.shape[0]==1:
            theta = np.loadtxt(MuelMatrx, delimiter=" ", skiprows=1, usecols=0)[:len(theta_grid)]
                
        if i == initial_run:
            theta = np.loadtxt(MuelMatrx, delimiter=" ", skiprows=1, usecols=0)[:len(theta_grid)]
        S11_muel[:len(theta),j] = np.loadtxt(MuelMatrx, delimiter=" ", skiprows=1, usecols=1)[:len(theta)]
        
        CrossSecY = Mainfolder + "run" +run + "_" + \
        particle_shape + "_sub"+ substrate_presence+ "_g" + number_of_dipoles_in_a_row + \
        "_m" + str(PS_n[j])+ "_R" + str(a) +"\\CrossSec-Y"         #Y cross sections
              
        CrossSecX_candidate = Mainfolder + "run" + run + "_" + \
        particle_shape + "_sub"+ substrate_presence+ "_g" + number_of_dipoles_in_a_row + \
        "_m" + str(PS_n[j])+ "_R" + str(a) +"\\CrossSec-X"    #X cross sections

        # If CrossSec-X exists, use it. Otherwise, fall back to CrossSec-Y (example due to symmetry)
        if os.path.exists(CrossSecX_candidate):
            CrossSecX = CrossSecX_candidate
        else:
            CrossSecX = CrossSecY
        

        columnY = []
        with open(CrossSecY) as f:
            for line in f:
                parts = line.strip().split()
                if len(parts) == 3:
                    columnY.append([float(parts[2])])
        
        columnX = []
        with open(CrossSecX) as f:
            for line in f:
                parts = line.strip().split()
                if len(parts) == 3:
                    columnX.append([float(parts[2])])
        
        Pol_Y[:,j] = np.array(columnY).flatten()
        Pol_X[:,j] = np.array(columnX).flatten()
        
        #loads cross sections and efficiency factors from the CrossSec files, for each wavelength index j. 
        
        Q_abs_ADDA_autoY[j]=Pol_Y[3,j]
        Q_ext_ADDA_autoY[j]=Pol_Y[1,j]
        Q_abs_ADDA_autoX[j]=Pol_X[3,j] 
        Q_ext_ADDA_autoX[j]=Pol_X[1,j]
        
        C_abs_ADDA_autoY[j]=Pol_Y[2,j] 
        C_ext_ADDA_autoY[j]=Pol_Y[0,j]
        C_abs_ADDA_autoX[j]=Pol_X[2,j] 
        C_ext_ADDA_autoX[j]=Pol_X[0,j]
        
        Q_sca_ADDA_intY[j]=Pol_Y[5,j] #these output are shown only if -Csca option is selected and it useful to check that everything is correct.
        Q_sca_ADDA_intX[j]=Pol_X[5,j]
        
        C_sca_ADDA_intY[j]=Pol_Y[4,j] 
        C_sca_ADDA_intX[j]=Pol_X[4,j]
        
    Q_abs_ADDA_auto=(Q_abs_ADDA_autoY+Q_abs_ADDA_autoX)/2    #averages for different directions
    Q_ext_ADDA_auto=(Q_ext_ADDA_autoY+Q_ext_ADDA_autoX)/2    
    Q_sca_ADDA_int=(Q_sca_ADDA_intY+Q_sca_ADDA_intX)/2
    
    C_abs_ADDA_auto=(C_abs_ADDA_autoY+C_abs_ADDA_autoX)/2
    C_ext_ADDA_auto=(C_ext_ADDA_autoY+C_ext_ADDA_autoX)/2    
    C_sca_ADDA_int=(C_sca_ADDA_intY+C_sca_ADDA_intX)/2
        
    theta_90_lab=int(np.round(len(theta_grid)/2)+1)
    theta_91_lab_lab=int(np.round(len(theta_grid)/2)+2)
    
    print(f'90° is set as line {theta_90_lab}')
    
    if substrate_presence=="no":
        theta_angle_for = theta[:theta_90_lab] #defines set of angle for forward scattering (0-90°). 361 label correspond to theta=90° if ngrid=720 (step=0.25°). otherwise change
        theta_angle_back = theta[theta_91_lab_lab:]
    if substrate_presence=="yes": #while working in substrate mode, theta angle must be reversed to assume that positive z axis direction is the impinging light direction...
        theta_angle_for = theta[theta_91_lab_lab:] 
        theta_angle_back = theta[:theta_90_lab]

        
    Q_ext_ADDA= np.zeros(len(wavelength))
    Q_sca_for_ADDA=np.zeros(len(wavelength))
    Q_sca_back_ADDA=np.zeros(len(wavelength))
    C_ext_ADDA= np.zeros(len(wavelength))    
    C_sca_for_ADDA=np.zeros(len(wavelength))
    C_sca_back_ADDA=np.zeros(len(wavelength))
    Q_sca_Mie_for=np.zeros(len(wavelength))
    Q_sca_Mie_back=np.zeros(len(wavelength))
    Q_ext_Mie=np.zeros(len(wavelength))
    C_sca_ADDA_int_tot=np.zeros(len(wavelength))

    x=np.zeros(len(wavelength))
    
    for k in range(len(wavelength)):
        x[k]=2*np.pi*a/wavelength[k]    #compute size parameter
        
        if substrate_presence=="no":
            S11_muel_for = S11_muel[:theta_90_lab, k]
            S11_muel_back = S11_muel[theta_91_lab_lab:, k]
            
        if substrate_presence=="yes": #while working in substrate mode, theta angle must be reversed to assume that positive z axis direction is the impinging light direction...
            S11_muel_for = S11_muel[theta_91_lab_lab:, k]
            S11_muel_back = S11_muel[:theta_90_lab:, k]            
        
        if substrate_presence=="no": #in substrate mode, the scattering effeciency propagating in the substrate must be divided by the refr index of the subatrate square, but shall not be done of course if no sbstrate is present.
            sub_n[k]=1
        
        dtheta=theta_grid[1]-theta_grid[0]
        
        Q_sca_for_ADDA[k] = 2*x[k]**(-2)*np.sum(S11_muel_for*np.sin(theta_angle_for*np.pi/180)*dtheta*2*np.pi/360)/sub_n[k]**2    #integrates forward scattering efficencies assuming SPHERES!
        Q_sca_back_ADDA[k] = 2*x[k]**(-2)*np.sum(S11_muel_back*np.sin(theta_angle_back*np.pi/180)*dtheta*2*np.pi/360)
        Q_ext_ADDA[k]=(4/x[k]**2)*(S11_muel_for[0]) #compute Qext
    
        C_sca_for_ADDA[k] = (wavelength[k]/1000)**2/(2*np.pi)*np.sum(S11_muel_for*np.sin(theta_angle_for*np.pi/180)*dtheta*2*np.pi/360)/sub_n[k]**2 #integrates forward scattering cross section. output is in micrometers
        C_sca_back_ADDA[k] = (wavelength[k]/1000)**2/(2*np.pi)*np.sum(S11_muel_back*np.sin(theta_angle_back*np.pi/180)*dtheta*2*np.pi/360) #integrates backward scattering cross section. output is in micrometers
        C_ext_ADDA[k]=(4/x[k]**2)*(S11_muel_for[0])*np.pi*a**2/(1000000) #still experimental, is not working properly...
        
        C_sca_ADDA_int_tot[k]=C_sca_back_ADDA[k]+C_sca_for_ADDA[k]
        
        #Mie scattering efficiencies assuming spheres
        
        Q_ext_Mie[k]=Qext_Mie(PS_n[k]-1j*PS_k[k],wavelength[k],a)
        Q_sca_Mie_for[k]=QSca_Mie_for(PS_n[k]-1j*PS_k[k],wavelength[k],a)
        Q_sca_Mie_back[k]=QSca_Mie_back(PS_n[k]-1j*PS_k[k],wavelength[k],a)

    print('Upload from ADDA successfull')
    
    #stacks results and save them in the SimResfolder defined at the start
    
    resultQ=np.column_stack((wavelength,Q_ext_ADDA_auto,Q_abs_ADDA_auto,Q_ext_ADDA,Q_sca_for_ADDA,Q_sca_back_ADDA,Q_sca_ADDA_int,Q_ext_Mie,Q_sca_Mie_for,Q_sca_Mie_back))
    resultC=np.column_stack((wavelength,C_ext_ADDA_auto,C_abs_ADDA_auto,C_sca_ADDA_int,C_sca_ADDA_int_tot,C_sca_for_ADDA,C_sca_back_ADDA))    
    
    filename_Q = f"Simulation_result_Q_R{int(a)}_{int(wavelength[0])}_{int(wavelength[-1])}_{particle_shape}_sub{substrate_presence}.txt"
    full_pathQ = os.path.join(SimResfolder, filename_Q)
    np.savetxt(full_pathQ,resultQ,fmt='%.6f',header='wavelength Q_ext_ADDA_auto Q_abs_ADDA_auto Q_ext_ADDA Q_sca_for_ADDA Q_sca_back_ADDA Q_sca_ADDA_int Q_ext_Mie Q_sca_Mie_for Q_sca_Mie_back')
    
    filename_C = f"Simulation_result_C_R{int(a)}_{int(wavelength[0])}_{int(wavelength[-1])}_{particle_shape}_sub{substrate_presence}.txt"
    full_pathC = os.path.join(SimResfolder, filename_C)
    np.savetxt(full_pathC,resultC,fmt='%.6f',header='wavelength C_ext_ADDA_auto C_abs_ADDA_auto C_sca_ADDA_int C_sca_ADDA_int_tot C_sca_ADDA_int_tot_for C_sca_ADDA_int_tot_back')
  
    print(f'txt files saved in {SimResfolder}')  
  
    return

def upload_grid(a):      #upload values from a simulation, calculates scattering quantities and saves them in a .txt file. USE WITH -store_scat_grid
# Handle the run parameters
    if wavelength.shape[0] > 1:
        initial_run = int(wavelength[0])
        step_lambda = int(wavelength[1] - wavelength[0])
        final_run = initial_run + step_lambda * wavelength.shape[0]
    else:
        initial_run = int(wavelength[0])
        step_lambda = 1   # no step if only one point
        final_run = initial_run+step_lambda
    
    S11_muel_grid = np.zeros((len(theta_grid)*len(phi_grid), wavelength.shape[0]))  #inizialize arrays
    S11_theta = np.zeros((len(theta_grid)*len(phi_grid), wavelength.shape[0]))
    S11_phi = np.zeros((len(theta_grid)*len(phi_grid), wavelength.shape[0]))
    
    Pol_Y = np.zeros((6, wavelength.shape[0]))
    Pol_X = np.zeros((6, wavelength.shape[0]))
    Q_ext_ADDA_autoY = np.zeros(wavelength.shape[0])
    Q_abs_ADDA_autoY = np.zeros(wavelength.shape[0])
    Q_ext_ADDA_autoX = np.zeros(wavelength.shape[0])
    Q_abs_ADDA_autoX = np.zeros(wavelength.shape[0])
    Q_sca_ADDA_intY = np.zeros(wavelength.shape[0])
    Q_sca_ADDA_intX = np.zeros(wavelength.shape[0])
    
    C_ext_ADDA_autoY = np.zeros(wavelength.shape[0])
    C_abs_ADDA_autoY = np.zeros(wavelength.shape[0])
    C_ext_ADDA_autoX = np.zeros(wavelength.shape[0])
    C_abs_ADDA_autoX = np.zeros(wavelength.shape[0])
    C_sca_ADDA_intY = np.zeros(wavelength.shape[0])
    C_sca_ADDA_intX = np.zeros(wavelength.shape[0])
    
    for j, wl in enumerate(wavelength):
        i = int(wl)  # wavelength value, used for folder naming
        
        if i<10:
            run = "00" + str(i)
        if i>=10 and i<100:
            run = "0" + str(i)
        else:
            run = str(i)       
               
        #j = int((i - initial_run)/step_lambda)
        
        MuelMatrxGrid = Mainfolder +"run" + run + "_" + \
        particle_shape + "_sub"+ substrate_presence+ "_g" + number_of_dipoles_in_a_row + \
        "_m" + str(PS_n[j]) + "_R" + str(a) +"\\mueller_scatgrid"

        
        S11_muel_grid[:,j]=np.loadtxt(MuelMatrxGrid,delimiter=" ", skiprows=1, usecols=2)     
        S11_theta[:,j]=np.loadtxt(MuelMatrxGrid,delimiter=" ", skiprows=1, usecols=0)
        S11_phi[:,j]=np.loadtxt(MuelMatrxGrid,delimiter=" ", skiprows=1, usecols=1)
        
        CrossSecY = Mainfolder +"run" + run + "_" + \
        particle_shape + "_sub"+ substrate_presence+ "_g" + number_of_dipoles_in_a_row + \
        "_m" + str(PS_n[j])+ "_R" + str(a) +"\\CrossSec-Y" #"_R" + str(a) + 
        
        CrossSecX_candidate = Mainfolder +"run" + run + "_" + \
        particle_shape + "_sub"+ substrate_presence+ "_g" + number_of_dipoles_in_a_row + \
        "_m" + str(PS_n[j])+ "_R" + str(a) +"\\CrossSec-X"    #X cross sections

        # If CrossSec-X exists, use it. Otherwise, fall back to CrossSec-Y (example due to symmetry)
        if os.path.exists(CrossSecX_candidate):
            CrossSecX = CrossSecX_candidate
        else:
            CrossSecX = CrossSecY
 
        
        columnY = []
        with open(CrossSecY) as f:
            for line in f:
                parts = line.strip().split()
                if len(parts) == 3:
                    columnY.append([float(parts[2])])
        
        columnX = []
        with open(CrossSecX) as f:
            for line in f:
                parts = line.strip().split()
                if len(parts) == 3:
                    columnX.append([float(parts[2])])
        
        Pol_Y[:,j] = np.array(columnY).flatten()
        Pol_X[:,j] = np.array(columnX).flatten()
        
        Q_abs_ADDA_autoY[j]=Pol_Y[3,j] 
        Q_ext_ADDA_autoY[j]=Pol_Y[1,j]
        Q_abs_ADDA_autoX[j]=Pol_X[3,j] 
        Q_ext_ADDA_autoX[j]=Pol_X[1,j]
        
        C_abs_ADDA_autoY[j]=Pol_Y[2,j] 
        C_ext_ADDA_autoY[j]=Pol_Y[0,j]
        C_abs_ADDA_autoX[j]=Pol_X[2,j] 
        C_ext_ADDA_autoX[j]=Pol_X[0,j]
        
        Q_sca_ADDA_intY[j]=Pol_Y[5,j] 
        Q_sca_ADDA_intX[j]=Pol_X[5,j]
        
        C_sca_ADDA_intY[j]=Pol_Y[4,j] 
        C_sca_ADDA_intX[j]=Pol_X[4,j]
        
    Q_abs_ADDA_auto=(Q_abs_ADDA_autoY+Q_abs_ADDA_autoX)/2
    Q_ext_ADDA_auto=(Q_ext_ADDA_autoY+Q_ext_ADDA_autoX)/2    
    Q_sca_ADDA_int=(Q_sca_ADDA_intY+Q_sca_ADDA_intX)/2
    
    C_abs_ADDA_auto=(C_abs_ADDA_autoY+C_abs_ADDA_autoX)/2
    C_ext_ADDA_auto=(C_ext_ADDA_autoY+C_ext_ADDA_autoX)/2    
    C_sca_ADDA_int=(C_sca_ADDA_intY+C_sca_ADDA_intX)/2
        
        #load Qext directly from CrossSection calculation of output folder, for each wavelength.

        
    Q_ext_ADDA= np.zeros(len(wavelength))
    Q_sca_for_ADDA=np.zeros(len(wavelength))
    Q_sca_back_ADDA=np.zeros(len(wavelength))
    C_ext_ADDA= np.zeros(len(wavelength))    
    C_sca_for_ADDA=np.zeros(len(wavelength))
    C_sca_back_ADDA=np.zeros(len(wavelength))
    Q_sca_Mie_for=np.zeros(len(wavelength))
    Q_sca_Mie_back=np.zeros(len(wavelength))
    Q_ext_Mie=np.zeros(len(wavelength))
    C_sca_ADDA_int_tot=np.zeros(len(wavelength))
    C_sca_ADDA_int_tot_for=np.zeros(len(wavelength))
    C_sca_ADDA_int_tot_back=np.zeros(len(wavelength))
    x=np.zeros(len(wavelength))
    
    for k in range(len(wavelength)):
        #print(wavelength[k])
        x[k]=2*np.pi*a/wavelength[k]    #compute size parameter
        
        dtheta=(S11_theta[len(phi_grid),0]-S11_theta[0,0])*np.pi/180 #step of theta, as defined in muel_scatgrid        
        dphi=(S11_phi[1,0]-S11_phi[0,0])*np.pi/180 #step of phi, as defined in muel_scatgrid
        theta_90_index=int(len(phi_grid)*((len(theta_grid)-1))/2)  #defines the number of row corresponding to theta=90°
        
        if k==0:
            print(f'90° is set as {theta_90_index}')
        
        if substrate_presence=="no": #while working in substrate mode, theta angle must be reversed to assume that positive z axis direction is the impinging light direction...
            C_sca_ADDA_int_tot_for[k] = (((wavelength[k]/1000)**2)/(4*np.pi**2))*np.sum(S11_muel_grid[:theta_90_index,k]*np.sin(S11_theta[:theta_90_index,k]*np.pi/180)*dtheta*dphi)
            C_sca_ADDA_int_tot_back[k] = (((wavelength[k]/1000)**2)/(4*np.pi**2))*np.sum(S11_muel_grid[theta_90_index:,k]*np.sin(S11_theta[theta_90_index:,k]*np.pi/180)*dtheta*dphi)
            C_sca_ADDA_int_tot[k] = (((wavelength[k]/1000)**2)/(4*np.pi**2))*np.sum(S11_muel_grid[:,k]*np.sin(S11_theta[:,k]*np.pi/180)*dtheta*dphi)  #total cross section, assuming no substrate

        if substrate_presence=="yes": #while working in substrate mode, theta angle must be reversed to assume that positive z axis direction is the impinging light direction...
            C_sca_ADDA_int_tot_for[k] = (((wavelength[k]/1000)**2)/(4*np.pi**2))*np.sum(S11_muel_grid[theta_90_index:,k]*np.sin(S11_theta[theta_90_index:,k]*np.pi/180)*dtheta*dphi)/sub_n[k]**2
            C_sca_ADDA_int_tot_back[k] = (((wavelength[k]/1000)**2)/(4*np.pi**2))*np.sum(S11_muel_grid[:theta_90_index,k]*np.sin(S11_theta[:theta_90_index,k]*np.pi/180)*dtheta*dphi)
            C_sca_ADDA_int_tot[k] =  C_sca_ADDA_int_tot_back[k]+C_sca_ADDA_int_tot_for[k]
        
        Q_ext_Mie[k]=Qext_Mie(PS_n[k]-1j*PS_k[k],wavelength[k],a)
        Q_sca_Mie_for[k]=QSca_Mie_for(PS_n[k]-1j*PS_k[k],wavelength[k],a)
        Q_sca_Mie_back[k]=QSca_Mie_back(PS_n[k]-1j*PS_k[k],wavelength[k],a)

    print('Upload from ADDA successfull')
    
    #stacks results and save them in the SimResfolder defined at the start
    
    resultQ=np.column_stack((wavelength,Q_ext_ADDA_auto,Q_abs_ADDA_auto,Q_ext_ADDA,Q_sca_for_ADDA,Q_sca_back_ADDA,Q_sca_ADDA_int,Q_ext_Mie,Q_sca_Mie_for,Q_sca_Mie_back))
    resultC=np.column_stack((wavelength,C_ext_ADDA_auto,C_abs_ADDA_auto,C_sca_ADDA_int,C_sca_ADDA_int_tot,C_sca_ADDA_int_tot_for,C_sca_ADDA_int_tot_back))    
    
    
    filename_Q = f"Simulation_result_Q_R{int(a)}_{int(wavelength[0])}_{int(wavelength[-1])}_{particle_shape}_sub{substrate_presence}_fromgrid.txt"
    full_pathQ = os.path.join(SimResfolder, filename_Q)
    np.savetxt(full_pathQ,resultQ,fmt='%.6f',header='wavelength Q_ext_ADDA_auto Q_abs_ADDA_auto Q_ext_ADDA Q_sca_for_ADDA Q_sca_back_ADDA Q_sca_ADDA_int Q_ext_Mie Q_sca_Mie_for Q_sca_Mie_back')
    
    filename_C = f"Simulation_result_C_R{int(a)}_{int(wavelength[0])}_{int(wavelength[-1])}_{particle_shape}_sub{substrate_presence}_fromgrid.txt"
    full_pathC = os.path.join(SimResfolder, filename_C)
    np.savetxt(full_pathC,resultC,fmt='%.6f',header='wavelength C_ext_ADDA_auto C_abs_ADDA_auto C_sca_ADDA_int C_sca_ADDA_int_tot C_sca_ADDA_int_tot_for C_sca_ADDA_int_tot_back')
  
    print(f'txt files saved in {SimResfolder}')      
    return
    
def plot(a):    
    a_value=str(int(a))
    
    data_input_C= f"Simulation_result_C_R{int(a)}_{int(wavelength[0])}_{int(wavelength[-1])}_{particle_shape}_sub{substrate_presence}.txt"
    full_pathC = os.path.join(SimResfolder, data_input_C)
    
    data_input_Q= f"Simulation_result_Q_R{int(a)}_{int(wavelength[0])}_{int(wavelength[-1])}_{particle_shape}_sub{substrate_presence}.txt"
    full_pathQ = os.path.join(SimResfolder, data_input_Q)
    
    #load efficiencies

    Q_ext_ADDA_auto=np.loadtxt(full_pathQ,skiprows=1, usecols=1)
    Q_abs_ADDA_auto=np.loadtxt(full_pathQ,skiprows=1, usecols=2)
    Q_sca_for_ADDA=np.loadtxt(full_pathQ,skiprows=1, usecols=4)
    Q_sca_back_ADDA=np.loadtxt(full_pathQ,skiprows=1, usecols=5)    
    Q_ext_Mie=np.loadtxt(full_pathQ,skiprows=1, usecols=7)
    Q_sca_Mie_for=np.loadtxt(full_pathQ,skiprows=1, usecols=8)
    Q_sca_Mie_back=np.loadtxt(full_pathQ,skiprows=1, usecols=9)    
    
    Q_ext_ADDA=Q_ext_ADDA_auto  #skip the definition from muel matrx (#TODO: FIX) and use directly the CrossSec output
       
    #load scattering cross sections
    C_ext_ADDA_auto=np.loadtxt(full_pathC,skiprows=1, usecols=1)
    C_abs_ADDA_auto=np.loadtxt(full_pathC,skiprows=1, usecols=2)
    C_sca_ADDA_int=np.loadtxt(full_pathC,skiprows=1, usecols=3)
    C_sca_ADDA_int_tot=np.loadtxt(full_pathC,skiprows=1, usecols=4)
    C_sca_ADDA_int_tot_for=np.loadtxt(full_pathC,skiprows=1, usecols=5)
    C_sca_ADDA_int_tot_back=np.loadtxt(full_pathC,skiprows=1, usecols=6)
    
   
    fig, (ax1)=pylab.subplots(1,1,figsize=(4,8), dpi=600)
    
    ax1.plot(wavelength,Q_ext_Mie,'--',color=(0,1,0),label='ext Mie')
    ax1.plot(wavelength,Q_sca_Mie_for,'--',color=(1,0,0),label='sca for Mie')
    ax1.plot(wavelength,Q_sca_Mie_back,'--',color=(0,0.3,1),label='sca back Mie')
    ax1.plot(wavelength,Q_ext_ADDA,color='green',label='ext ADDA auto')
    ax1.plot(wavelength,Q_sca_for_ADDA,color=(0.5,0,0),label='sca for ADDA')
    ax1.plot(wavelength,Q_sca_back_ADDA,color=(0,0,0.5),label='sca back ADDA')
    ax1.legend(loc="upper right", fontsize="small", frameon=True,framealpha=0)
    ax1.set_title(f"Efficency factors ADDA vs Mie, R={a_value}nm")


    fig2, (ax4)=pylab.subplots(1,1,figsize=(4,8), dpi=600)
    ax4.plot(wavelength,C_sca_ADDA_int_tot_for,color=(0,0,0),label='Csca for')
    ax4.plot(wavelength,C_sca_ADDA_int_tot_back,color=(1,0,0),label='Csca back')
    ax4.plot(wavelength,C_sca_ADDA_int_tot,color=(0,0.8,0),label='Csca for+Csca back ')
    ax4.plot(wavelength,C_sca_ADDA_int,'--',color=(0,0,1),label='Csca out ADDA')
    ax4.plot(wavelength,C_abs_ADDA_auto,color=(1,0,1),label='Cabs auto')
    ax4.plot(wavelength,C_ext_ADDA_auto,color=(0,0.8,1),label='Cext auto')
    ax4.legend(loc="upper right", fontsize="small", frameon=True,framealpha=0)
    ax4.set_title(f"ADDA Scattering cross sections, R={a_value}nm")
      
    return
 
def plot_grid(a):    
     a_value=str(int(a))
     
     data_input_C= f"Simulation_result_C_R{int(a)}_{int(wavelength[0])}_{int(wavelength[-1])}_{particle_shape}_sub{substrate_presence}_fromgrid.txt"
     full_pathC = os.path.join(SimResfolder, data_input_C)
     
     data_input_Q= f"Simulation_result_Q_R{int(a)}_{int(wavelength[0])}_{int(wavelength[-1])}_{particle_shape}_sub{substrate_presence}_fromgrid.txt"
     full_pathQ = os.path.join(SimResfolder, data_input_Q)
     
     #load efficiencies

     Q_ext_ADDA_auto=np.loadtxt(full_pathQ,skiprows=1, usecols=1)
     Q_abs_ADDA_auto=np.loadtxt(full_pathQ,skiprows=1, usecols=2)
     Q_sca_for_ADDA=np.loadtxt(full_pathQ,skiprows=1, usecols=4)
     Q_sca_back_ADDA=np.loadtxt(full_pathQ,skiprows=1, usecols=5)    
     Q_ext_Mie=np.loadtxt(full_pathQ,skiprows=1, usecols=7)
     Q_sca_Mie_for=np.loadtxt(full_pathQ,skiprows=1, usecols=8)
     Q_sca_Mie_back=np.loadtxt(full_pathQ,skiprows=1, usecols=9)    
     
     Q_ext_ADDA=Q_ext_ADDA_auto  #skip the definition from muel matrx (#TODO: FIX) and use directly the CrossSec output
        
     #load scattering cross sections
     C_ext_ADDA_auto=np.loadtxt(full_pathC,skiprows=1, usecols=1)
     C_abs_ADDA_auto=np.loadtxt(full_pathC,skiprows=1, usecols=2)
     C_sca_ADDA_int=np.loadtxt(full_pathC,skiprows=1, usecols=3)
     C_sca_ADDA_int_tot=np.loadtxt(full_pathC,skiprows=1, usecols=4)
     C_sca_ADDA_int_tot_for=np.loadtxt(full_pathC,skiprows=1, usecols=5)
     C_sca_ADDA_int_tot_back=np.loadtxt(full_pathC,skiprows=1, usecols=6)
     
    
     fig, (ax1)=pylab.subplots(1,1,figsize=(4,8), dpi=600)
     
     ax1.plot(wavelength,Q_ext_Mie,'--',color=(0,1,0),label='ext Mie')
     ax1.plot(wavelength,Q_sca_Mie_for,'--',color=(1,0,0),label='sca for Mie')
     ax1.plot(wavelength,Q_sca_Mie_back,'--',color=(0,0.3,1),label='sca back Mie')
     ax1.plot(wavelength,Q_ext_ADDA,color='green',label='ext ADDA auto')
     ax1.plot(wavelength,Q_sca_for_ADDA,color=(0.5,0,0),label='sca for ADDA')
     ax1.plot(wavelength,Q_sca_back_ADDA,color=(0,0,0.5),label='sca back ADDA')
     ax1.legend(loc="upper right", fontsize="small", frameon=True,framealpha=0)
     ax1.set_title(f"Efficency factors ADDA vs Mie, R={a_value}nm")


     fig2, (ax4)=pylab.subplots(1,1,figsize=(4,8), dpi=600)
     ax4.plot(wavelength,C_sca_ADDA_int_tot_for,color=(0,0,0),label='Csca for')
     ax4.plot(wavelength,C_sca_ADDA_int_tot_back,color=(1,0,0),label='Csca back')
     ax4.plot(wavelength,C_sca_ADDA_int_tot,color=(0,0.8,0),label='Csca for+Csca back ')
     ax4.plot(wavelength,C_sca_ADDA_int,'--',color=(0,0,1),label='Csca out ADDA')
     ax4.plot(wavelength,C_abs_ADDA_auto,color=(1,0,1),label='Cabs auto')
     ax4.plot(wavelength,C_ext_ADDA_auto,color=(0,0.8,1),label='Cext auto')
     ax4.legend(loc="upper right", fontsize="small", frameon=True,framealpha=0)
     ax4.set_title(f"ADDA Scattering cross sections, R={a_value}nm")
       
     return   

################################## CALCULATIONS ##############################################

def QSca_Mie_for(m,lambda0,a):  #(refractive index, wavelength, radius) computes the forward scattering efficency. to compare ADDA and Mie results for spheres. needs Miepython module in the win64 directory.
    theta_angle_forM = np.arange(start=0, stop=0.5*np.pi+0.00000001,step=np.pi/100000) #defines set of angle for forward scattering (0-90°) 
    x=2*np.pi*a/lambda0    #compute size parameter
    mu_for=np.cos(theta_angle_forM)  #compute cosine of the selected angle range, serves as input of _mie_S1_S2 function
    norm_int = 6 #Fix Wiscombe normalization, necessary to make results consistent.
    S1_for,S2_for=miepython._mie_S1_S2(m, x, mu_for,  norm_int) #compute amplitude function for forward scattering
    Q_sca_for = x**(-2)*np.sum(((np.abs(S1_for)**2 + np.abs(S2_for)**2)*np.sin(theta_angle_forM)*np.pi/100000))
    #print(Q_sca_for)
    #pylab.plot(theta_angle_forM,S1_for,color='red')
    return Q_sca_for

def QSca_Mie_back(m,lambda0,a):  #(refractive index, wavelength, radius) computes the backward scattering efficency. need Miepython module
    theta_angle_forM = np.arange(start=0.5*np.pi, stop=1*np.pi+0.00000001,step=np.pi/100000) #defines set of angle for forward scattering (0-90°) 
    x=2*np.pi*a/lambda0    #compute size parameter
    mu_for=np.cos(theta_angle_forM)  #compute cosine of the selected angle range, serves as input of _mie_S1_S2 function
    norm_int = 6 #Fix Wiscombe normalization, necessary to make results consistent.
    S1_for,S2_for=miepython._mie_S1_S2(m, x, mu_for,  norm_int) #compute amplitude function for forward scattering
    Q_sca_back = x**(-2)*np.sum(((np.abs(S1_for)**2 + np.abs(S2_for)**2)*np.sin(theta_angle_forM)*np.pi/100000))
    #print(Q_sca_back)
    #pylab.plot(theta_angle_forM,S1_for,color='red')
    return Q_sca_back

def Qext_Mie(m,lambda0,a): #computes the exctintion scattering efficency. need Miepython module
    x=2*np.pi*a/lambda0
    norm_int=6
    mu_0= np.arange(start=1.0, stop=1.01,step=0.1) #Qext depend only on the value of S for theta=0. mu_0 is an array with one element (costheta=1), because to adjust the normalization the input angle for _mie_s1_s2 must be an array 
    norm_int = 6
    S1_0, S2_0 = miepython._mie_S1_S2(m,x,mu_0, norm_int) #compute amplitude function at theta=0
    Q_ext_A = 4*(1/x**2)*S1_0.real #compute Qext
    Q_ext=float(Q_ext_A[0])
    return Q_ext


def upload_mult_r():        #used to load values from folder of sets of simulation with the sizes specified by "radius" array.
    for j in range(radius.shape[0]):
         upload(radius[j])
         plot(radius[j])
    return

def go_mult_radius():       #start simulation for each dimension specified in "radius array", with the commands specified in generate_bat_files, one dimension at a time.
    start_time_tot=time.time()
    for j in range(radius.shape[0]):
        go(radius[j])
    
    print(f'Simulation from {radius[0]} to {radius[-1]} performed!!')
    
    print(f"Whole process took: {time.time() - start_time_tot:.2f} seconds")
    for j in range(radius.shape[0]):
         upload(radius[j])
         plot(radius[j])
    print("Done!")
    #plot_lognormal_mean()
    return
